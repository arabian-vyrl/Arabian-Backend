// const axios = require("axios");
// const xml2js = require("xml2js");
// const SaleProperty = require("../Models/SalePropertyModel");
// const RentProperty = require("../Models/RentPropertyModel");
// const OffPlanProperty = require("../Models/OffplanModel");
// const CommercialProperty = require("../Models/CommercialPropertyModel");
// const Agent = require("../Models/AgentModel");
// const NonActiveProperties = require('../Models/Nonactiveproperties');

// // Simple QR code extraction function
// const extractQRCodeUrl = (qrCode) => {
//   if (!qrCode) return '';

//   console.log(`DEBUG - QR Code structure:`, JSON.stringify(qrCode, null, 2));

//   // Case 1: Direct string
//   if (typeof qrCode === 'string') {
//     console.log(`DEBUG - QR code is direct string:`, qrCode);
//     return qrCode;
//   }

//   // Case 2: Object with url property (most common case based on your XML)
//   if (qrCode.url) {
//     // If url is a string directly
//     if (typeof qrCode.url === 'string') {
//       console.log(`DEBUG - Found QR URL (direct string):`, qrCode.url);
//       return qrCode.url;
//     }

//     // If url is an object with text content (xml2js parsing)
//     if (typeof qrCode.url === 'object') {
//       // Handle xml2js parsed text content (_ property contains the actual URL)
//       if (qrCode.url._) {
//         console.log(`DEBUG - Found QR URL (url._):`, qrCode.url._);
//         return qrCode.url._;
//       }

//       // Handle $t property (another xml2js text content property)
//       if (qrCode.url.$t) {
//         console.log(`DEBUG - Found QR URL (url.$t):`, qrCode.url.$t);
//         return qrCode.url.$t;
//       }
//     }

//     // If url is an array (multiple URLs, take first)
//     if (Array.isArray(qrCode.url) && qrCode.url.length > 0) {
//       const firstUrl = qrCode.url[0];
//       if (typeof firstUrl === 'string') {
//         console.log(`DEBUG - Found QR URL (array string):`, firstUrl);
//         return firstUrl;
//       }
//       if (firstUrl && (firstUrl._ || firstUrl.$t)) {
//         const url = firstUrl._ || firstUrl.$t;
//         console.log(`DEBUG - Found QR URL (array object):`, url);
//         return url;
//       }
//     }
//   }

//   // Case 3: Direct text content at qr_code level
//   if (qrCode._ || qrCode.$t) {
//     const url = qrCode._ || qrCode.$t;
//     console.log(`DEBUG - Found QR URL (direct text):`, url);
//     return url;
//   }

//   console.log(`DEBUG - No QR URL found`);
//   return '';
// };

// // NEW FUNCTION: Check if property status is Live
// const isPropertyLive = (propertyData) => {
//   const status = propertyData.general_listing_information?.status;
//   const isLive = status && status.toLowerCase() === 'live';
//   console.log(`DEBUG - Property ${propertyData.id}: Status = "${status}", IsLive = ${isLive}`);
//   return isLive;
// };

// // UPDATED FUNCTION: Determine property type based on completion_status and offering_type (only for Live properties)
// const determinePropertyType = (customFields) => {
//   const completionStatus = customFields?.completion_status;
//   const offeringType = customFields?.offering_type;

//   console.log(`DEBUG - Property classification: completion_status=${completionStatus}, offering_type=${offeringType}`);

//   // FIRST: Check completion_status for off-plan properties
//   if (completionStatus === 'off_plan_primary' || completionStatus === 'off_plan_secondary') {
//     console.log(`DEBUG - Property classified as OffPlan due to completion_status: ${completionStatus}`);
//     return {
//       type: 'OffPlan',
//       listingType: 'OffPlan',
//       reason: `completion_status is ${completionStatus}`
//     };
//   }

//   // SECOND: If not off-plan, check offering_type
//   if (offeringType === 'RR') {
//     console.log(`DEBUG - Property classified as Rent due to offering_type: ${offeringType}`);
//     return {
//       type: 'Rent',
//       listingType: 'Rent',
//       reason: `offering_type is ${offeringType}`
//     };
//   } else if (offeringType === 'RS') {
//     console.log(`DEBUG - Property classified as Sale due to offering_type: ${offeringType}`);
//     return {
//       type: 'Sale',
//       listingType: 'Sale',
//       reason: `offering_type is ${offeringType}`
//     };
//   } else if (offeringType === 'CS' || offeringType === 'CR') {
//     console.log(`DEBUG - Property classified as Commercial due to offering_type: ${offeringType}`);
//     return {
//       type: 'Commercial',
//       listingType: 'Commercial',
//       reason: `offering_type is ${offeringType}`
//     };
//   }

//   // FALLBACK: Default to Sale if no clear classification
//   console.log(`DEBUG - Property defaulted to Sale - completion_status: ${completionStatus}, offering_type: ${offeringType}`);
//   return {
//     type: 'Sale',
//     listingType: 'Sale',
//     reason: `Fallback - no clear classification found`
//   };
// };

// const parseXmlFromUrl = async (req, res, next) => {
//   try {
//     const xmlUrl = process.env.XML_URL;
//     console.log(`Fetching XML from: ${xmlUrl}`);
//     const response = await axios.get(xmlUrl, {
//       headers: { Accept: "application/xml" },
//     });

//     const parser = new xml2js.Parser({
//       explicitArray: false,
//       mergeAttrs: true,
//       normalize: true,
//       normalizeTags: false,
//       trim: true,
//     });

//     console.log("Parsing XML data...");
//     const result = await parser.parseStringPromise(response.data);

//     let allProperties = [];

//     // Handle the new XML structure - properties are directly in the list
//     if (result && result.list && result.list.property) {
//       if (Array.isArray(result.list.property)) {
//         allProperties = result.list.property;
//       } else {
//         allProperties = [result.list.property];
//       }
//     } else {
//       // Fallback to find properties array
//       const findPropertiesArray = (obj) => {
//         for (const key in obj) {
//           if (
//             Array.isArray(obj[key]) &&
//             obj[key].length > 0 &&
//             obj[key][0] &&
//             (obj[key][0].general_listing_information || obj[key][0].Id)
//           ) {
//             return obj[key];
//           } else if (typeof obj[key] === "object" && obj[key] !== null) {
//             const found = findPropertiesArray(obj[key]);
//             if (found) return found;
//           }
//         }
//         return null;
//       };

//       const propertiesArray = findPropertiesArray(result);
//       if (propertiesArray) {
//         allProperties = propertiesArray;
//       }
//     }

//     console.log(`Found ${allProperties.length} properties in XML`);

//     // Transform new XML format to match existing structure
//     const transformPropertyData = (property) => {
//       // Debug QR code structure for troubleshooting
//       if (property.custom_fields?.qr_code) {
//         console.log(`DEBUG - Property ${property.Id}: QR Code found in custom_fields`);
//       } else {
//         console.log(`DEBUG - Property ${property.Id}: No QR Code found in custom_fields`);
//       }

//       // Map new structure to old structure
//       const transformedProperty = {
//         id: property.Id || property.id,
//         mode: "CREATE", // Default mode since new XML doesn't have mode
//         created_at: property.created_at,
//         timestamp: property.timestamp,

//         // Transform address information
//         address_information: property.address_information || {},

//         // Transform general listing information - INITIAL MAPPING (classification will be determined later for Live properties)
//         general_listing_information: {
//           listing_title: property.general_listing_information?.listing_title || "",
//           listingprice: property.general_listing_information?.listingprice || "0",
//           listingtype: property.general_listing_information?.listingtype || "Sale", // Temporary, will be updated for Live properties
//           currency_iso_code: property.general_listing_information?.currency_iso_code || "AED",
//           property_type: property.general_listing_information?.property_type || "apartment",
//           status: property.general_listing_information?.status || "Live",
//           totalarea: property.general_listing_information?.totalarea || "0",
//           description: property.general_listing_information?.description || "",
//           bedrooms: property.general_listing_information?.bedrooms || "0",
//           fullbathrooms: property.general_listing_information?.fullbathrooms || "0",
//           // Map property_type to both propertytype and property for schema compatibility
//           propertytype: property.general_listing_information?.property_type || "apartment",
//           property: property.general_listing_information?.property_type || "apartment"
//         },

//         // Transform listing agent
//         listing_agent: {
//           listing_agent_email: property.listing_agent?.listing_agent_email || "",
//           listing_agent_firstname: property.listing_agent?.listing_agent_firstname || "",
//           listing_agent_lastname: property.listing_agent?.listing_agent_lastname || "",
//           listing_agent_mobil_phone: property.listing_agent?.listing_agent_mobil_phone || "",
//           listing_agent_phone: property.listing_agent?.listing_agent_phone || property.listing_agent?.listing_agent_mobil_phone || ""
//         },

//         // Transform custom fields - mapping ALL fields from new XML format
//         custom_fields: {
//           // New XML fields - direct mapping
//           property_record_id: property.custom_fields?.property_record_id || "",
//           permit_number: property.custom_fields?.permit_number || "",
//           offering_type: property.custom_fields?.offering_type || "",
//           price_on_application: property.custom_fields?.price_on_application || "No",
//           payment_method: property.custom_fields?.payment_method || "",
//           city: property.custom_fields?.city || "",
//           community: property.custom_fields?.community || "",
//           sub_community: property.custom_fields?.sub_community || "",
//           property_name: property.custom_fields?.property_name || "",
//           propertyfinder_region: property.custom_fields?.propertyfinder_region || "",
//           autonumber: property.custom_fields?.autonumber || "",
//           unitnumber: property.custom_fields?.unitnumber || "",
//           private_amenities: property.custom_fields?.private_amenities || "",
//           plot_size: property.custom_fields?.plot_size || "0",
//           developer: property.custom_fields?.developer || "",
//           completion_status: property.custom_fields?.completion_status || "completed",
//           parking: property.custom_fields?.parking || "0",
//           furnished: property.custom_fields?.furnished || "No",
//           project_name: property.custom_fields?.project_name || "",
//           title_deed: property.custom_fields?.title_deed || "",
//           availability_date: property.custom_fields?.availability_date || "",

//           // Map to the field names your existing code expects for backward compatibility
//           community_name: property.custom_fields?.community || "",
//           tower_text: property.custom_fields?.property_name || "",
//           pba__addresstext_pb: property.custom_fields?.propertyfinder_region || "",

//           // Map completion status for OffPlan detection with multiple variants
//           pba_uaefields__completion_status: 
//             property.custom_fields?.completion_status === "off_plan_primary" || 
//             property.custom_fields?.completion_status === "off_plan_secondary" ? "Off Plan" : "Completed",

//           // Store QR code URL as string - SIMPLIFIED VERSION
//           qr_code: extractQRCodeUrl(property.custom_fields?.qr_code),

//           // Additional fields that might be in the XML but not captured yet
//           sub_community_name: property.custom_fields?.sub_community || "",
//           building_name: property.custom_fields?.property_name || "",
//           rera_permit_number: property.custom_fields?.permit_number || "",
//           plot_area: property.custom_fields?.plot_size || "0",
//           completion_date: property.custom_fields?.availability_date || "",

//           // Map any other fields dynamically - but exclude qr_code to avoid object storage
//           ...Object.keys(property.custom_fields || {}).reduce((acc, key) => {
//             // Don't override already mapped fields and skip qr_code to avoid storing object
//             if (!acc[key] && key !== 'qr_code' && property.custom_fields[key] !== undefined) {
//               acc[key] = property.custom_fields[key];
//             }
//             return acc;
//           }, {})
//         },

//         // Transform listing media with proper image handling for nested URL structures
//         listing_media: {
//           images: {
//             image: (() => {
//               const images = property.listing_media?.images?.image;
//               if (!images) return [];

//               // Handle array of images
//               if (Array.isArray(images)) {
//                 return images.map(img => {
//                   if (typeof img === 'string') {
//                     return { title: '', url: img };
//                   }

//                   // Handle nested url structure from xml2js parsing
//                   if (img.url) {
//                     if (typeof img.url === 'string') {
//                       return { title: img.title || '', url: img.url };
//                     } else if (Array.isArray(img.url)) {
//                       // Handle array of URLs within single image
//                       return img.url.map(urlItem => ({
//                         title: urlItem.title || '',
//                         url: urlItem._ || urlItem.$t || urlItem
//                       }));
//                     } else if (img.url._ || img.url.$t) {
//                       return { title: img.url.title || '', url: img.url._ || img.url.$t };
//                     }
//                   }

//                   return img;
//                 }).flat(); // Flatten in case of nested arrays
//               }

//               // Handle single image object
//               if (images.url) {
//                 if (Array.isArray(images.url)) {
//                   return images.url.map(urlItem => ({
//                     title: urlItem.title || '',
//                     url: urlItem._ || urlItem.$t || urlItem
//                   }));
//                 } else if (typeof images.url === 'string') {
//                   return [{ title: images.title || '', url: images.url }];
//                 } else if (images.url._ || images.url.$t) {
//                   return [{ title: images.url.title || '', url: images.url._ || images.url.$t }];
//                 }
//               }

//               return [];
//             })()
//           }
//         },

//         // Add QR code at root level for easier access - SIMPLIFIED VERSION
//         qr_code: extractQRCodeUrl(property.custom_fields?.qr_code)
//       };

//       return transformedProperty;
//     };

//     // Transform all properties to match expected structure
//     const transformedProperties = allProperties.map(transformPropertyData);

//     // Filter valid properties (all are valid since we're setting mode to CREATE)
//     const validProperties = transformedProperties.filter(property => {
//       const mode = property.mode;
//       if (mode === "CREATE" || mode === "CHANGE" || mode === "NEW") {
//         return true;
//       }
//       console.log(`Skipping property ${property.id} with mode: ${mode}`);
//       return false;
//     });

//     console.log(`Processing ${validProperties.length} properties`);

//     // UPDATED: Separate properties by status FIRST
//     const liveProperties = [];
//     const nonLiveProperties = [];

//     validProperties.forEach(property => {
//       if (isPropertyLive(property)) {
//         // For Live properties, determine the proper classification
//         const propertyClassification = determinePropertyType(property.custom_fields);
//         console.log(`DEBUG - Live Property ${property.id}: Classified as ${propertyClassification.type} (${propertyClassification.reason})`);

//         // Update the listingtype for Live properties
//         property.general_listing_information.listingtype = propertyClassification.listingType;
//         property._classification = propertyClassification;

//         liveProperties.push(property);
//       } else {
//         // For non-Live properties, add to non-active without classification
//         console.log(`DEBUG - Non-Live Property ${property.id}: Status = "${property.general_listing_information?.status}", moving to NonActive`);
//         property._classification = {
//           type: 'NonActive',
//           listingType: 'NonActive',
//           reason: `Status is not Live: ${property.general_listing_information?.status}`
//         };

//         nonLiveProperties.push(property);
//       }
//     });

//     console.log(`Live properties: ${liveProperties.length}`);
//     console.log(`Non-Live properties: ${nonLiveProperties.length}`);

//     // UPDATED Helper functions with new classification logic
//     const getModelByListingType = (listingType) => {
//       if (listingType === "Sale") {
//         return SaleProperty;
//       } else if (listingType === "Rent") {
//         return RentProperty;
//       } else if (listingType === "OffPlan") {
//         return OffPlanProperty;
//       } else if (listingType === "Commercial") {
//         return CommercialProperty;
//       } else if (listingType === "NonActive") {
//         return NonActiveProperties;
//       }
//       return null;
//     };

//     const findExistingProperty = async (propertyId, listingType) => {
//       const Model = getModelByListingType(listingType);
//       if (!Model) return null;

//       try {
//         const existingProperty = await Model.findOne({ id: propertyId });
//         return existingProperty;
//       } catch (error) {
//         console.error(`Error finding existing property ${propertyId}:`, error);
//         return null;
//       }
//     };

//     // UPDATED: Remove property from other collections when it changes type
//     const removePropertyFromOtherCollections = async (propertyId, currentListingType) => {
//       const allModels = [
//         { name: 'Sale', model: SaleProperty },
//         { name: 'Rent', model: RentProperty },
//         { name: 'OffPlan', model: OffPlanProperty },
//         { name: 'Commercial', model: CommercialProperty },
//         { name: 'NonActive', model: NonActiveProperties }
//       ];

//       const removedFrom = [];

//       for (const modelInfo of allModels) {
//         if (modelInfo.name !== currentListingType) {
//           try {
//             const deleted = await modelInfo.model.deleteOne({ id: propertyId });
//             if (deleted.deletedCount > 0) {
//               console.log(`Removed property ${propertyId} from ${modelInfo.name} collection`);
//               removedFrom.push(modelInfo.name);
//             }
//           } catch (error) {
//             console.error(`Error removing property ${propertyId} from ${modelInfo.name} collection:`, error);
//           }
//         }
//       }

//       return removedFrom;
//     };

//     const validateAndCleanPropertyData = (propertyData) => {
//       try {
//         if (typeof propertyData.address_information === "string") {
//           propertyData.address_information = {};
//         }

//         if (!propertyData.general_listing_information) {
//           propertyData.general_listing_information = {};
//         }

//         if (!propertyData.general_listing_information.listingprice) {
//           propertyData.general_listing_information.listingprice = "0";
//           console.log(`Warning: Property ${propertyData.id} missing price, setting to 0`);
//         }

//         if (!propertyData.general_listing_information.propertytype) {
//           propertyData.general_listing_information.propertytype = propertyData.general_listing_information.property_type || "Unknown";
//         }

//         // Ensure the required 'property' field is set for schema compatibility
//         if (!propertyData.general_listing_information.property) {
//           propertyData.general_listing_information.property = propertyData.general_listing_information.property_type || propertyData.general_listing_information.propertytype || "Unknown";
//         }

//         if (!propertyData.general_listing_information.status) {
//           propertyData.general_listing_information.status = "Active";
//         }

//         if (!propertyData.general_listing_information.bedrooms) {
//           propertyData.general_listing_information.bedrooms = "0";
//         }

//         if (!propertyData.general_listing_information.fullbathrooms) {
//           propertyData.general_listing_information.fullbathrooms = "0";
//         }

//         if (!propertyData.general_listing_information.totalarea) {
//           propertyData.general_listing_information.totalarea = "0";
//         }

//         if (!propertyData.general_listing_information.currency_iso_code) {
//           propertyData.general_listing_information.currency_iso_code = "AED";
//         }

//         if (propertyData.listing_agent) {
//           if (!propertyData.listing_agent.listing_agent_phone) {
//             propertyData.listing_agent.listing_agent_phone =
//               propertyData.listing_agent.listing_agent_mobil_phone || "Unknown";
//           }

//           if (!propertyData.listing_agent.listing_agent_mobil_phone) {
//             propertyData.listing_agent.listing_agent_mobil_phone =
//               propertyData.listing_agent.listing_agent_phone || "Unknown";
//           }
//         }

//         if (!propertyData.custom_fields) {
//           propertyData.custom_fields = {};
//         }

//         // SIMPLIFIED QR code validation - extract URL string if it's an object
//         if (propertyData.custom_fields.qr_code && typeof propertyData.custom_fields.qr_code === 'object') {
//           const extractedUrl = extractQRCodeUrl(propertyData.custom_fields.qr_code);
//           propertyData.custom_fields.qr_code = extractedUrl;
//           console.log(`DEBUG - Validation: Extracted QR URL for ${propertyData.id}:`, extractedUrl);
//         }

//         return { success: true, data: propertyData };
//       } catch (error) {
//         return { success: false, error: error.message };
//       }
//     };

//     // UPDATED Function to create property data for agent linking (only for Live properties)
//     const createPropertyDataForAgent = (propertyData) => {
//       const generalInfo = propertyData.general_listing_information || {};
//       const addressInfo = propertyData.address_information || {};
//       const customFields = propertyData.custom_fields || {};

//       // Use the new classification logic
//       const listingType = generalInfo.listingtype || 'Sale';

//       return {
//         propertyId: propertyData.id,
//         listingTitle: generalInfo.listing_title || 'No Title',
//         listingType: listingType,
//         propertyType: generalInfo.propertytype || generalInfo.property_type || 'Unknown',
//         price: generalInfo.listingprice || '0',
//         currency: generalInfo.currency_iso_code || 'AED',
//         status: generalInfo.status || 'Active',
//         bedrooms: generalInfo.bedrooms || '0',
//         bathrooms: generalInfo.fullbathrooms || '0',
//         area: generalInfo.totalarea || '0',
//         location: {
//           city: customFields.city || addressInfo.city || '',
//           address: customFields.propertyfinder_region || addressInfo.address || '',
//           community: customFields.community || '',
//           building: customFields.property_name || ''
//         },
//         images: propertyData.listing_media?.images?.image || [],
//         description: generalInfo.description || '',
//         addedDate: new Date(),
//         lastUpdated: new Date()
//       };
//     };

//     // Function to link property to existing agent (only for Live properties)
//     const linkPropertyToAgent = async (propertyData) => {
//       try {
//         const listingAgent = propertyData.listing_agent;

//         if (!listingAgent || !listingAgent.listing_agent_email) {
//           return {
//             success: false,
//             operation: 'skipped',
//             reason: 'No agent email found in property data'
//           };
//         }

//         const agentEmail = listingAgent.listing_agent_email.toLowerCase().trim();

//         // Find existing agent by email
//         const existingAgent = await Agent.findOne({ 
//           email: agentEmail,
//           isActive: true 
//         });

//         if (!existingAgent) {
//           return {
//             success: false,
//             operation: 'agent_not_found',
//             reason: `No active agent found with email: ${agentEmail}`
//           };
//         }

//         // Create property data
//         const propertyDataForAgent = createPropertyDataForAgent(propertyData);

//         // Check if property already exists in agent's properties
//         const existingPropertyIndex = existingAgent.properties?.findIndex(
//           p => p.propertyId === propertyData.id
//         );

//         if (!existingAgent.properties) {
//           existingAgent.properties = [];
//         }

//         if (existingPropertyIndex > -1) {
//           // Update existing property
//           existingAgent.properties[existingPropertyIndex] = {
//             ...existingAgent.properties[existingPropertyIndex],
//             ...propertyDataForAgent,
//             lastUpdated: new Date()
//           };
//           console.log(`Updated property ${propertyData.id} for agent ${agentEmail}`);
//         } else {
//           // Add new property
//           existingAgent.properties.push(propertyDataForAgent);
//           console.log(`Added property ${propertyData.id} to agent ${agentEmail}`);
//         }

//         // Update agent's active sale listings count
//         const activeSaleCount = existingAgent.properties.filter(
//           p => p.listingType === 'Sale' && p.status !== 'Off Market'
//         ).length;

//         existingAgent.activeSaleListings = activeSaleCount;
//         existingAgent.lastUpdated = new Date();

//         await existingAgent.save();

//         return {
//           success: true,
//           operation: existingPropertyIndex > -1 ? 'property_updated' : 'property_added',
//           agentEmail: agentEmail,
//           agentName: existingAgent.agentName,
//           totalProperties: existingAgent.properties.length,
//           activeSaleListings: existingAgent.activeSaleListings
//         };

//       } catch (error) {
//         console.error(`Error linking property ${propertyData.id} to agent:`, error);
//         return {
//           success: false,
//           operation: 'failed',
//           error: error.message
//         };
//       }
//     };

//     // UPDATED: Main save function with status filtering logic
//     const saveOrUpdatePropertyToDb = async (propertyData) => {
//       try {
//         let mode = propertyData.mode;
//         if (mode === "NEW") {
//           mode = "CREATE";
//           propertyData.mode = "CREATE";
//         }

//         console.log(`Processing property ${propertyData.id} with mode: ${mode}`);

//         // Validate and clean property data
//         const validationResult = validateAndCleanPropertyData(propertyData);
//         if (!validationResult.success) {
//           return {
//             success: false,
//             error: `Data validation failed: ${validationResult.error}`,
//             operationResults: {
//               mode: mode,
//               mainOperation: 'failed',
//               agentOperation: 'failed',
//               errors: [validationResult.error]
//             }
//           };
//         }

//         propertyData = validationResult.data;

//         // USE CLASSIFICATION FROM PROPERTY
//         const listingType = propertyData._classification.listingType;
//         console.log(`DEBUG - Property ${propertyData.id}: Final listingType = ${listingType}`);

//         const operationResults = {
//           mode: mode,
//           listingType: listingType,
//           isLive: listingType !== 'NonActive',
//           isOffPlan: listingType === 'OffPlan',
//           isCommercial: listingType === 'Commercial',
//           isNonActive: listingType === 'NonActive',
//           mainOperation: null,
//           cleanupOperations: [],
//           agentOperation: null,
//           errors: []
//         };

//         const SpecificModel = getModelByListingType(listingType);

//         if (!SpecificModel) {
//           operationResults.errors.push(`No model found for listing type: ${listingType}`);
//           return {
//             success: false,
//             operationResults: operationResults,
//             error: `No model found for listing type: ${listingType}`
//           };
//         }

//         try {
//           // Remove property from other collections first
//           const removedFrom = await removePropertyFromOtherCollections(propertyData.id, listingType);
//           operationResults.cleanupOperations = removedFrom;

//           // Find existing property in the correct collection
//           const existingProperty = await findExistingProperty(propertyData.id, listingType);

//           if (existingProperty) {
//             // Update existing property
//             const updatedProperty = await SpecificModel.findOneAndUpdate(
//               { id: propertyData.id },
//               propertyData,
//               { new: true, upsert: false }
//             );
//             console.log(`Updated existing property ${propertyData.id} in ${SpecificModel.modelName}`);
//             operationResults.mainOperation = 'updated';
//           } else {
//             // Create new property
//             const newProperty = new SpecificModel(propertyData);
//             const savedProperty = await newProperty.save();
//             console.log(`Created new property ${savedProperty.id} in ${SpecificModel.modelName}`);
//             operationResults.mainOperation = 'created';
//           }

//           // Link property to agent ONLY if it's a Live property (not NonActive)
//           if (listingType !== 'NonActive') {
//             const agentResult = await linkPropertyToAgent(propertyData);
//             operationResults.agentOperation = agentResult.operation;
//             if (!agentResult.success) {
//               operationResults.errors.push(`Agent operation failed: ${agentResult.error || agentResult.reason}`);
//             }
//           } else {
//             operationResults.agentOperation = 'skipped_nonactive';
//             console.log(`Skipped agent linking for non-active property ${propertyData.id}`);
//           }

//         } catch (error) {
//           console.error(`Error processing property ${propertyData.id}:`, error);
//           operationResults.mainOperation = 'failed';
//           operationResults.errors.push(`Main operation failed: ${error.message}`);
//         }

//         const isSuccess = operationResults.mainOperation === 'created' || 
//                          operationResults.mainOperation === 'updated' ||
//                          operationResults.mainOperation === 'skipped';

//         return {
//           success: isSuccess,
//           operationResults: operationResults,
//           error: isSuccess ? null : operationResults.errors.join('; ')
//         };

//       } catch (error) {
//         console.error(`Error in saveOrUpdatePropertyToDb for property ${propertyData.id || "unknown"}:`, error);
//         return {
//           success: false,
//           error: error.message,
//           operationResults: {
//             mode: propertyData.mode,
//             mainOperation: 'failed',
//             agentOperation: 'failed',
//             errors: [error.message]
//           }
//         };
//       }
//     };

//     console.log("Starting to process all properties...");

//     // UPDATED: Process results tracking with status-based categories
//     const processResults = {
//       totalAttempted: validProperties.length,
//       livePropertiesAttempted: liveProperties.length,
//       nonLivePropertiesAttempted: nonLiveProperties.length,
//       successful: 0,
//       failed: 0,
//       skipped: allProperties.length - validProperties.length,
//       failures: [],
//       operations: {
//         created: 0,
//         updated: 0,
//         skipped: 0,
//         agentPropertiesAdded: 0,
//         agentPropertiesUpdated: 0,
//         agentNotFound: 0,
//         agentSkipped: 0,
//         agentSkippedNonActive: 0,
//         agentFailed: 0
//       },
//       byType: {
//         Sale: { created: 0, updated: 0, skipped: 0 },
//         Rent: { created: 0, updated: 0, skipped: 0 },
//         OffPlan: { created: 0, updated: 0, skipped: 0 },
//         Commercial: { created: 0, updated: 0, skipped: 0 },
//         NonActive: { created: 0, updated: 0, skipped: 0 },
//         Other: { created: 0, updated: 0, skipped: 0 }
//       },
//       statusStats: {
//         liveProcessed: 0,
//         nonLiveProcessed: 0,
//         statusBreakdown: {}
//       },
//       classificationStats: {
//         byCompletionStatus: {},
//         byOfferingType: {},
//         fallbacks: 0
//       }
//     };

//     // Process Live properties first
//     console.log(`Processing ${liveProperties.length} Live properties...`);
//     for (let i = 0; i < liveProperties.length; i++) {
//       try {
//         const property = liveProperties[i];

//         // Track classification stats for Live properties
//         const completionStatus = property.custom_fields?.completion_status;
//         const offeringType = property.custom_fields?.offering_type;
//         const classification = property._classification;

//         if (completionStatus) {
//           processResults.classificationStats.byCompletionStatus[completionStatus] = 
//             (processResults.classificationStats.byCompletionStatus[completionStatus] || 0) + 1;
//         }

//         if (offeringType) {
//           processResults.classificationStats.byOfferingType[offeringType] = 
//             (processResults.classificationStats.byOfferingType[offeringType] || 0) + 1;
//         }

//         if (classification && classification.reason.includes('Fallback')) {
//           processResults.classificationStats.fallbacks++;
//         }

//         const result = await saveOrUpdatePropertyToDb(property);

//         if (result.success) {
//           processResults.successful++;
//           processResults.statusStats.liveProcessed++;

//           const ops = result.operationResults;

//           // Track main operations
//           if (ops.mainOperation === 'created') {
//             processResults.operations.created++;
//             if (processResults.byType[ops.listingType]) {
//               processResults.byType[ops.listingType].created++;
//             } else {
//               processResults.byType.Other.created++;
//             }
//           } else if (ops.mainOperation === 'updated') {
//             processResults.operations.updated++;
//             if (processResults.byType[ops.listingType]) {
//               processResults.byType[ops.listingType].updated++;
//             } else {
//               processResults.byType.Other.updated++;
//             }
//           } else if (ops.mainOperation === 'skipped') {
//             processResults.operations.skipped++;
//             if (processResults.byType[ops.listingType]) {
//               processResults.byType[ops.listingType].skipped++;
//             } else {
//               processResults.byType.Other.skipped++;
//             }
//           }

//           // Track Agent operations
//           if (ops.agentOperation === 'property_added') {
//             processResults.operations.agentPropertiesAdded++;
//           } else if (ops.agentOperation === 'property_updated') {
//             processResults.operations.agentPropertiesUpdated++;
//           } else if (ops.agentOperation === 'agent_not_found') {
//             processResults.operations.agentNotFound++;
//           } else if (ops.agentOperation === 'skipped') {
//             processResults.operations.agentSkipped++;
//           } else if (ops.agentOperation === 'skipped_nonactive') {
//             processResults.operations.agentSkippedNonActive++;
//           } else if (ops.agentOperation === 'failed') {
//             processResults.operations.agentFailed++;
//           }

//           if (processResults.statusStats.liveProcessed % 10 === 0) {
//             console.log(`Progress (Live): ${processResults.statusStats.liveProcessed}/${liveProperties.length} Live properties processed`);
//           }
//         } else {
//           processResults.failed++;
//           processResults.failures.push({
//             id: property.id || `Unknown Live property at index ${i}`,
//             mode: property.mode || 'Unknown',
//             status: property.general_listing_information?.status || 'Unknown',
//             classification: property._classification,
//             error: result.error
//           });
//         }
//       } catch (error) {
//         console.error(`Error in Live property processing loop at index ${i}:`, error);
//         processResults.failed++;
//         processResults.failures.push({
//           id: liveProperties[i]?.id || `Unknown Live property at index ${i}`,
//           mode: liveProperties[i]?.mode || 'Unknown',
//           status: liveProperties[i]?.general_listing_information?.status || 'Unknown',
//           error: error.message
//         });
//       }
//     }

//     // Process Non-Live properties
//     console.log(`Processing ${nonLiveProperties.length} Non-Live properties...`);
//     for (let i = 0; i < nonLiveProperties.length; i++) {
//       try {
//         const property = nonLiveProperties[i];

//         // Track status breakdown for Non-Live properties
//         const status = property.general_listing_information?.status || 'Unknown';
//         processResults.statusStats.statusBreakdown[status] = 
//           (processResults.statusStats.statusBreakdown[status] || 0) + 1;

//         const result = await saveOrUpdatePropertyToDb(property);

//         if (result.success) {
//           processResults.successful++;
//           processResults.statusStats.nonLiveProcessed++;

//           const ops = result.operationResults;

//           // Track main operations
//           if (ops.mainOperation === 'created') {
//             processResults.operations.created++;
//             processResults.byType.NonActive.created++;
//           } else if (ops.mainOperation === 'updated') {
//             processResults.operations.updated++;
//             processResults.byType.NonActive.updated++;
//           } else if (ops.mainOperation === 'skipped') {
//             processResults.operations.skipped++;
//             processResults.byType.NonActive.skipped++;
//           }

//           // Track Agent operations (should be skipped_nonactive for all)
//           if (ops.agentOperation === 'skipped_nonactive') {
//             processResults.operations.agentSkippedNonActive++;
//           }

//           if (processResults.statusStats.nonLiveProcessed % 10 === 0) {
//             console.log(`Progress (Non-Live): ${processResults.statusStats.nonLiveProcessed}/${nonLiveProperties.length} Non-Live properties processed`);
//           }
//         } else {
//           processResults.failed++;
//           processResults.failures.push({
//             id: property.id || `Unknown Non-Live property at index ${i}`,
//             mode: property.mode || 'Unknown',
//             status: property.general_listing_information?.status || 'Unknown',
//             classification: property._classification,
//             error: result.error
//           });
//         }
//       } catch (error) {
//         console.error(`Error in Non-Live property processing loop at index ${i}:`, error);
//         processResults.failed++;
//         processResults.failures.push({
//           id: nonLiveProperties[i]?.id || `Unknown Non-Live property at index ${i}`,
//           mode: nonLiveProperties[i]?.mode || 'Unknown',
//           status: nonLiveProperties[i]?.general_listing_information?.status || 'Unknown',
//           error: error.message
//         });
//       }
//     }

//     console.log("Database processing operation completed.");
//     console.log(`Successfully processed ${processResults.successful} properties.`);
//     console.log(`Failed to process ${processResults.failed} properties.`);
//     console.log(`Skipped ${processResults.skipped} properties (invalid modes).`);
//     console.log(`Status Summary:`);
//     console.log(`  - Live properties processed: ${processResults.statusStats.liveProcessed}`);
//     console.log(`  - Non-Live properties processed: ${processResults.statusStats.nonLiveProcessed}`);
//     console.log(`Operations summary:`);
//     console.log(`  - Created: ${processResults.operations.created}`);
//     console.log(`  - Updated: ${processResults.operations.updated}`);
//     console.log(`  - Skipped: ${processResults.operations.skipped}`);
//     console.log(`  - Agent Properties Added: ${processResults.operations.agentPropertiesAdded}`);
//     console.log(`  - Agent Properties Updated: ${processResults.operations.agentPropertiesUpdated}`);
//     console.log(`  - Agent Not Found: ${processResults.operations.agentNotFound}`);
//     console.log(`  - Agent Skipped: ${processResults.operations.agentSkipped}`);
//     console.log(`  - Agent Skipped (Non-Active): ${processResults.operations.agentSkippedNonActive}`);
//     console.log(`  - Agent Failed: ${processResults.operations.agentFailed}`);

//     console.log(`Classification Summary (Live Properties Only):`);
//     console.log(`  - By Property Type:`);
//     console.log(`    * Sale: Created ${processResults.byType.Sale.created}, Updated ${processResults.byType.Sale.updated}`);
//     console.log(`    * Rent: Created ${processResults.byType.Rent.created}, Updated ${processResults.byType.Rent.updated}`);
//     console.log(`    * OffPlan: Created ${processResults.byType.OffPlan.created}, Updated ${processResults.byType.OffPlan.updated}`);
//     console.log(`    * Commercial: Created ${processResults.byType.Commercial.created}, Updated ${processResults.byType.Commercial.updated}`);
//     console.log(`    * NonActive: Created ${processResults.byType.NonActive.created}, Updated ${processResults.byType.NonActive.updated}`);
//     console.log(`  - By Completion Status:`, processResults.classificationStats.byCompletionStatus);
//     console.log(`  - By Offering Type:`, processResults.classificationStats.byOfferingType);
//     console.log(`  - Fallback Classifications: ${processResults.classificationStats.fallbacks}`);
//     console.log(`  - Non-Live Status Breakdown:`, processResults.statusStats.statusBreakdown);

//     return res.status(200).json({
//       success: true,
//       message: "XML data fetched, parsed, and processed successfully with status-based filtering",
//       totalPropertiesInXml: allProperties.length,
//       processedProperties: validProperties.length,
//       liveProperties: liveProperties.length,
//       nonLiveProperties: nonLiveProperties.length,
//       skippedProperties: processResults.skipped,
//       databaseResults: {
//         propertiesProcessed: processResults.successful,
//         propertiesFailed: processResults.failed,
//         operations: processResults.operations,
//         byType: processResults.byType,
//         statusStats: processResults.statusStats,
//         classificationStats: processResults.classificationStats,
//         failures: processResults.failures.slice(0, 10)
//       }
//     });

//   } catch (error) {
//     console.error("Error parsing XML:", error.message);
//     return res.status(500).json({
//       success: false,
//       message: "Failed to parse XML",
//       error: error.message,
//     });
//   }
// };

// module.exports = parseXmlFromUrl;




----LEADERBOARD-----
const clampInt = (v, def = 0) => {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : def;
};

function normalizeAgentName(name) {
  if (!name) return "";
  return String(name)
    .toLowerCase()
    .trim()
    .replace(/\s+/g, " ")
    .replace(/[^\w\s]/g, "");
}

// Remove leading slash from a relative URL path (so path.join works on Win/*nix)
const stripLeadingSlash = (p) =>
  typeof p === "string" ? p.replace(/^[/\\]+/, "") : p;

// -----------------------------
// Salesforce HTTP client
// -----------------------------
const SALESFORCE = {
  tokenUrl: process.env.SALESFORCE_TOKEN_URL,
  baseUrl: "https://arabianestates.my.salesforce.com",
  clientId: process.env.SALESFORCE_CLIENT_ID,
  clientSecret: process.env.SALESFORCE_CLIENT_SECRET,
  username: process.env.SALESFORCE_USERNAME,
  password: process.env.SALESFORCE_PASSWORD,
};

const axiosSF = axios.create({
  baseURL: SALESFORCE.baseUrl,
  timeout: 30_000,
  headers: { Accept: "application/json", "Content-Type": "application/json" },
});

// Simple retry helper for transient errors
async function withRetry(fn, { retries = 2, delayMs = 600 } = {}) {
  let lastErr;
  for (let i = 0; i <= retries; i++) {
    try {
      return await fn();
    } catch (err) {
      lastErr = err;
      const status = err?.response?.status;
      // Retry on 429/5xx/timeouts/ENOTFOUND/ECONNRESET
      const code = err?.code;
      const retryable =
        status === 429 ||
        (status >= 500 && status < 600) ||
        ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EAI_AGAIN"].includes(code);
      if (!retryable || i === retries) break;
      await new Promise((r) => setTimeout(r, delayMs * (i + 1)));
    }
  }
  throw lastErr;
}

// Wrap a GET to Apex REST with auto token + retry
async function sfGet(pathname, params = {}) {
  const token = await getSalesforceToken();
  return withRetry(() =>
    axiosSF.get(pathname, {
      params,
      headers: { Authorization: `Bearer ${token}` },
    })
  );
}

// Allowed values for ?month=
const ALLOWED_MONTH = new Set([
  "this_month",
  "last_month",
  "last_3_months",
  "last_6_months",
  "ytd",
  "last_12_months",
]);



function getUtcYearMonth(date) {
  const d = new Date(date);
  return { y: d.getUTCFullYear(), m: d.getUTCMonth() }; // 0..11
}

function resolveMonthUTC(monthParam = "this_month") {
  const now = new Date();
  let y = now.getUTCFullYear();
  let m = now.getUTCMonth();

  if (monthParam === "last_month") {
    if (m === 0) {
      y -= 1;
      m = 11;
    } else {
      m -= 1;
    }
  } else if (/^\d{4}-\d{2}$/.test(monthParam)) {
    const [yy, mm] = monthParam.split("-").map(Number);
    y = yy;
    m = mm - 1;
  }
  return { targetY: y, targetM: m };
}

function isSameUtcMonth(dateString, targetY, targetM) {
  if (!dateString) return false;
  const t = Date.parse(dateString);
  if (Number.isNaN(t)) return false;
  const { y, m } = getUtcYearMonth(t);
  return y === targetY && m === targetM;
}
//

// CRON FUNCTIONS
async function getSalesforceToken() {
  // console.log("Working")
  try {
    const resp = await axios.post(SALESFORCE.tokenUrl, null, {
      params: {
        grant_type: "password",
        client_id: SALESFORCE.clientId,
        client_secret: SALESFORCE.clientSecret,
        username: SALESFORCE.username,
        password: SALESFORCE.password,
      },
    });
    return resp.data.access_token;
  } catch (error) {
    console.error("âŒ Failed to generate Salesforce token:", error.message);
    throw new Error("Salesforce token generation failed");
  }
}

async function aggregateDeals(monthParam) {
  const { targetY, targetM } = resolveMonthUTC(monthParam);

  // Pull both datasets exactly as requested (no coercion)
  const [monthlyDealsResp, ytdDealsResp] = await Promise.all([
    sfGet("/services/apexrest/deals", { month: monthParam }),
    sfGet("/services/apexrest/deals", { month: "ytd" }),
  ]);

  const monthlyDealsRaw = monthlyDealsResp?.data?.deals || [];
  const ytdDealsRaw = ytdDealsResp?.data?.deals || [];

  // Strict UTC month filter on createddate (same as commissions)
  const monthlyDeals = monthlyDealsRaw.filter((d) =>
    isSameUtcMonth(d.createddate, targetY, targetM)
  );

  const agents = await Agent.find({ isActive: true });
  const agentMap = new Map(
    agents.map((a) => [normalizeAgentName(a.agentName), a])
  );

  // ===== MONTHLY DEAL COUNTS =====
  const dealCountsByAgent = new Map();
  const unmatchedMonthly = [];

  for (const deal of monthlyDeals) {
    const names = twoAgentNamesOnly(deal);
    if (names.length === 0) continue;

    for (const nm of names) {
      const key = normalizeAgentName(nm);
      if (!key || !agentMap.has(key)) {
        if (nm && !unmatchedMonthly.includes(nm)) unmatchedMonthly.push(nm);
        continue;
      }
      dealCountsByAgent.set(key, (dealCountsByAgent.get(key) || 0) + 1);
    }
  }

  // ===== YTD LAST DEAL DATE =====
  const agentLastDealDateYTD = new Map();
  const unmatchedYtd = [];

  for (const deal of ytdDealsRaw) {
    const names = twoAgentNamesOnly(deal);
    if (names.length === 0) continue;

    const created = deal.createddate;
    const dealDate = created ? new Date(created) : null;
    if (!dealDate || Number.isNaN(dealDate.getTime())) continue;

    for (const nm of names) {
      const key = normalizeAgentName(nm);
      if (!key) continue;

      if (!agentMap.has(key)) {
        if (nm && !unmatchedYtd.includes(nm)) unmatchedYtd.push(nm);
        continue;
      }

      const prev = agentLastDealDateYTD.get(key);
      if (!prev || dealDate > prev) agentLastDealDateYTD.set(key, dealDate);
    }
  }

  return {
    targetY,
    targetM,
    monthlyDealsRaw,
    monthlyDeals,
    ytdDealsRawCount: ytdDealsRaw.length,
    dealCountsByAgent,
    agentLastDealDateYTD,
    unmatchedMonthly,
    unmatchedYtd,
    agentMap,
  };
}
function parseTarget(monthParam = "this_month") {
  // Returns { mode: 'monthly'|'ytd', targetY, targetM }
  if (monthParam === "ytd") {
    const now = new Date();
    return {
      mode: "ytd",
      targetY: now.getUTCFullYear(),
      targetM: now.getUTCMonth(),
    };
  }
  const { targetY, targetM } = resolveMonthUTC(monthParam);
  return { mode: "monthly", targetY, targetM };
}

function twoAgentNamesOnly(deal) {
  const names = [];
  if (deal.deal_agent) names.push(deal.deal_agent.trim());
  if (deal.deal_agent_2) names.push(deal.deal_agent_2.trim());
  return names.filter(Boolean);
}
async function syncDealsJob(month = "this_month") {
  try {
    // IMPORTANT: do NOT coerce with ensureValidMonth
    const {
      targetY,
      targetM,
      monthlyDealsRaw,
      monthlyDeals,
      ytdDealsRawCount,
      dealCountsByAgent,
      agentLastDealDateYTD,
      unmatchedMonthly,
      unmatchedYtd,
      agentMap,
    } = await aggregateDeals(month);

    const todayUTC = new Date();
    todayUTC.setUTCHours(0, 0, 0, 0);

    const ops = [];
    let agentsUpdated = 0;

    for (const [key, agent] of agentMap.entries()) {
      const dealCount = dealCountsByAgent.get(key) || 0;
      const lastDealDate = agentLastDealDateYTD.get(key) || null;

      let lastDealDays = null;
      if (lastDealDate) {
        const dealDateUTC = new Date(lastDealDate);
        dealDateUTC.setUTCHours(0, 0, 0, 0);
        lastDealDays = Math.max(
          0,
          Math.floor((todayUTC - dealDateUTC) / 86400000)
        );
      }

      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.propertiesSold": dealCount,
              "leaderboard.lastDealDate": lastDealDate,
              "leaderboard.lastDealDays": lastDealDays,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      if (dealCount > 0) agentsUpdated++;
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    console.log(
      `âœ… [CRON] DEALS-ONLY sync completed for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`
    );
    console.log(
      `   - Monthly deals (strict UTC filter): ${monthlyDeals.length}/${monthlyDealsRaw.length} returned`
    );
    console.log(`   - YTD deals scanned: ${ytdDealsRawCount}`);
    console.log(`   - Agents updated: ${agentsUpdated}`);
    if (unmatchedMonthly.length)
      console.log(
        `   - Unmatched (monthly sample):`,
        unmatchedMonthly.slice(0, 10)
      );
    if (unmatchedYtd.length)
      console.log(`   - Unmatched (ytd sample):`, unmatchedYtd.slice(0, 10));

    return {
      success: true,
      agentsUpdated,
      monthlyDeals: monthlyDeals.length,
      ytdDeals: ytdDealsRawCount,
    };
  } catch (error) {
    console.error("âŒ [CRON] Error syncing deals:", error.message);
    throw error;
  }
}

async function aggregateViewings(monthParam = "this_month") {
  const { targetY, targetM } = resolveMonthUTC(monthParam);

  const resp = await sfGet("/services/apexrest/viewings", {
    month: monthParam,
  });
  const raw = resp?.data?.viewings || [];

  // Strict UTC month filter on the 'start' field
  const viewings = raw.filter(
    (v) => v.start && isSameUtcMonth(v.start, targetY, targetM)
  );

  const agents = await Agent.find({ isActive: true });
  const agentMap = new Map(
    agents.map((a) => [normalizeAgentName(a.agentName), a])
  );

  const counts = new Map();
  const unmatchedOwners = new Set();

  for (const v of viewings) {
    const owner = v.owner || v.owner_name || v.agent_name || v.createdById;
    const key = normalizeAgentName(owner);
    if (!key) continue;

    if (agentMap.has(key)) {
      counts.set(key, (counts.get(key) || 0) + 1);
    } else if (owner) {
      unmatchedOwners.add(owner);
    }
  }

  return {
    targetY,
    targetM,
    viewings,
    counts,
    unmatchedOwners,
    agentMap,
    totalReturned: raw.length,
  };
}

async function syncViewingsJob(month = "this_month") {
  try {
    // âŒ Do NOT coerce with ensureValidMonth â€” accept YYYY-MM just like manual
    const {
      targetY,
      targetM,
      viewings,
      counts,
      unmatchedOwners,
      agentMap,
      totalReturned,
    } = await aggregateViewings(month);

    const ops = [];
    let agentsUpdated = 0;

    for (const [key, agent] of agentMap.entries()) {
      const viewingsCount = counts.get(key) || 0;

      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.viewings": viewingsCount,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      if (viewingsCount > 0) agentsUpdated++;
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    console.log(
      `âœ… [CRON] Viewings sync completed for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`
    );
    console.log(
      `   - Viewings after strict UTC filter: ${viewings.length}/${totalReturned} returned`
    );
    console.log(`   - Agents updated: ${agentsUpdated}`);
    if (unmatchedOwners.size)
      console.log(
        `   - Unmatched (sample):`,
        Array.from(unmatchedOwners).slice(0, 10)
      );

    return { success: true, agentsUpdated, totalViewings: viewings.length };
  } catch (error) {
    console.error("âŒ [CRON] Error syncing viewings:", error.message);
    throw error;
  }
}

function parseTarget(monthParam = "this_month") {
  // Returns { mode: 'monthly'|'ytd', targetY, targetM }
  if (monthParam === "ytd") {
    const now = new Date();
    return {
      mode: "ytd",
      targetY: now.getUTCFullYear(),
      targetM: now.getUTCMonth(),
    };
  }
  const { targetY, targetM } = resolveMonthUTC(monthParam);
  return { mode: "monthly", targetY, targetM };
}

function amountNumber(raw) {
  return typeof raw === "string"
    ? Number(raw.replace(/[, ]/g, ""))
    : Number(raw) || 0;
}

async function aggregateCommissions(monthParam) {
  const { mode, targetY, targetM } = parseTarget(monthParam);

  const commissionsResp = await sfGet("/services/apexrest/commissions", {
    month: monthParam,
  });
  const commissions = commissionsResp?.data?.commissions || [];

  const agents = await Agent.find();
  const agentMap = new Map(
    agents.map((a) => [normalizeAgentName(a.agentName), a])
  );

  const commissionsByAgent = new Map();
  const unmatchedCommissionAgents = [];
  let filteredCount = 0;

  for (const c of commissions) {
    const created = c.createddate;
    const inScope =
      mode === "ytd"
        ? created && new Date(created).getUTCFullYear() === targetY // keep same UTC year
        : isSameUtcMonth(created, targetY, targetM); // keep same UTC month

    if (!inScope) continue;

    filteredCount++;

    const agentName = c.agent_name || c.commission_agents;
    if (!agentName) continue;

    const key = normalizeAgentName(agentName);
    if (!agentMap.has(key)) {
      if (!unmatchedCommissionAgents.includes(agentName))
        unmatchedCommissionAgents.push(agentName);
      continue;
    }

    const raw = c.commission_amount_excl_vat ?? c.total_commissions ?? 0;
    const amt = amountNumber(raw);
    commissionsByAgent.set(key, (commissionsByAgent.get(key) || 0) + amt);
  }

  return {
    commissionsByAgent,
    unmatchedCommissionAgents,
    filteredCount,
    agentMap,
    targetY,
    targetM,
    mode,
  };
}

async function syncCommissionsJobNew(month = "this_month") {
  try {
    // IMPORTANT: do NOT coerce the month with ensureValidMonth
    const {
      commissionsByAgent,
      unmatchedCommissionAgents,
      filteredCount,
      agentMap,
      targetY,
      targetM,
    } = await aggregateCommissions(month);

    const ops = [];
    let agentsUpdated = 0;

    for (const [key, agent] of agentMap.entries()) {
      const totalCommission =
        Math.round((commissionsByAgent.get(key) || 0) * 100) / 100;

      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.totalCommission": totalCommission,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      if (totalCommission > 0) agentsUpdated++;
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    console.log(
      `âœ… [CRON] Commissions sync completed for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`
    );
    console.log(`   - Commission records synced: ${filteredCount}`);
    console.log(`   - Agents updated: ${agentsUpdated}`);
    if (unmatchedCommissionAgents.length) {
      console.log(
        `   - Unmatched (sample):`,
        unmatchedCommissionAgents.slice(0, 10)
      );
    }

    return { success: true, agentsUpdated, commissionRecords: filteredCount };
  } catch (error) {
    console.error("âŒ [CRON] Error syncing commissions:", error.message);
    throw error;
  }
}

async function syncMonthlyPropertiesJobNew() {
  try {
    console.log("ðŸ”„ [CRON] Starting monthly properties update...");

    const result = await Agent.updateAllAgentsMonthlyProperties();

    console.log(
      `âœ… [CRON] Monthly properties updated for ${result.agentsUpdated} agents`
    );
    return result;
  } catch (error) {
    console.error(
      "âŒ [CRON] Error updating monthly properties:",
      error.message
    );
    throw error;
  }
}
async function runAllSyncs() {
  console.log("â° [CRON] Starting scheduled Salesforce sync job...");
  const t0 = Date.now();
  try {
    // Run deals, commissions, and viewings in parallel
    await Promise.all([
      syncDealsJob(),
      syncCommissionsJobNew(),
      syncViewingsJob(),
    ]);

    // âœ… Run monthly properties after other syncs
    await syncMonthlyPropertiesJobNew();

    const sec = ((Date.now() - t0) / 1000).toFixed(2);
    console.log(`âœ… [CRON] All syncs completed successfully in ${sec}s`);
  } catch (error) {
    console.error("âŒ [CRON] Error in scheduled sync job:", error.message);
  }
}

let cronScheduled = false;
function setupCronJobs() {
  if (cronScheduled) {
    console.log("â„¹ï¸  Cron already scheduled; skipping duplicate registration.");
    return;
  }

  // âœ… Main sync job - every 15 minutes
   cron.schedule("*/15 * * * *", async () => {
    await runAllSyncs();
  });

  cronScheduled = true;
  console.log(
    "âœ… Cron job scheduled: Salesforce sync will run every 30 minutes"
  );

  // Optional: run immediately on startup
  console.log("ðŸš€ Running initial sync on startup...");
  runAllSyncs();
}

// async function runAllSyncs() {
//   console.log("â° [CRON] Starting scheduled Salesforce sync job...");
//   const t0 = Date.now();
//   try {
//     // Run deals, viewings, and offers in parallel
//     await Promise.all([syncDealsJob(), syncViewingsJob(),runSfCommissionSync()]);

//     // âœ… NEW: Run monthly properties after other syncs
//     await syncMonthlyPropertiesJob();

//     const sec = ((Date.now() - t0) / 1000).toFixed(2);
//     console.log(`âœ… [CRON] All syncs completed successfully in ${sec}s`);
//   } catch (error) {
//     console.error("âŒ [CRON] Error in scheduled sync job:", error.message);
//   }
// }
// Cron guard to avoid double scheduling in hot reload / clustered processes
// let cronScheduled = false;
// function setupCronJobs() {
//   if (cronScheduled) {
//     console.log("â„¹ï¸  Cron already scheduled; skipping duplicate registration.");
//     return;
//   }

//   // âœ… Main sync job - every 30 minutes
//   cron.schedule("*/30 * * * *", async () => {
//     await runAllSyncs();
//   });

//   cronScheduled = true;
//   console.log(
//     "âœ… Cron job scheduled: Salesforce sync will run every 30 minutes"
//   );

//   // Optional: run immediately on startup
//   console.log("ðŸš€ Running initial sync on startup...");
//   // Fire and forget
//   runAllSyncs();
// }

// Removed Offers cron not needed in backup for future if needed again
// async function syncOffersJob(month = "this_month") {
//   try {
//     month = ensureValidMonth(month);
//     console.log(`ðŸ”„ [CRON] Starting Salesforce offers sync for: ${month}`);

//     const { data } = await sfGet("/services/apexrest/Offers", { month });
//     const offers = data?.Offer || [];
//     if (!Array.isArray(offers) || offers.length === 0) {
//       console.log("ðŸ“Š No offers found in Salesforce");

//       // âœ… NEW: Reset all agents' offer count to 0 if no offers found
//       const agents = await Agent.find({ isActive: true });
//       const updatePromises = agents.map((agent) => {
//         agent.updateLeaderboardMetrics({ offers: 0 });
//         return agent.save();
//       });
//       await Promise.all(updatePromises);
//       console.log(`âœ… [CRON] Reset offers to 0 for ${agents.length} agents`);
//       return;
//     }

//     const agents = await Agent.find({ isActive: true });
//     const agentMap = new Map(
//       agents.map((a) => [normalizeAgentName(a.agentName), a])
//     );

//     const stats = {
//       totalOffers: offers.length,
//       agentsUpdated: 0,
//       offersByAgent: new Map(),
//     };

//     for (const o of offers) {
//       const key = normalizeAgentName(o.owner);
//       if (!key || !agentMap.has(key)) continue;
//       const cur = stats.offersByAgent.get(key) || 0;
//       stats.offersByAgent.set(key, cur + 1);
//     }

//     const updatePromises = [];

//     // âœ… IMPROVED: Update all agents, setting 0 for those without offers
//     for (const [key, agent] of agentMap.entries()) {
//       const count = stats.offersByAgent.get(key) || 0;
//       agent.updateLeaderboardMetrics({ offers: count });
//       updatePromises.push(agent.save());
//       if (count > 0) stats.agentsUpdated++;
//     }

//     await Promise.all(updatePromises);
//     console.log(
//       `âœ… [CRON] Offers sync completed. Updated ${stats.agentsUpdated} agents with offers`
//     );
//   } catch (error) {
//     console.error("âŒ [CRON] Error syncing offers:", error.message);
//   }
// }

// -----------------------------
// Manual API endpoints
// -----------------------------

const GetSalesForceToken = async (req, res) => {
  try {
    console.log("WORKING");
    const resp = await axios.post(SALESFORCE.tokenUrl, null, {
      params: {
        grant_type: "password",
        client_id: SALESFORCE.clientId,
        client_secret: SALESFORCE.clientSecret,
        username: SALESFORCE.username,
        password: SALESFORCE.password,
      },
    });
    console.log(resp.data.access_token);
    return res.status(200).json({
      access_token: resp.data.access_token,
    });
  } catch (error) {
    console.error("âŒ Failed to generate Salesforce token:", error.message);
    throw new Error("Salesforce token generation failed");
  }
};

// Fetching deals of agents amd days since last deal
const syncAgentDealsFromSalesforce = async (req, res) => {
  try {
    const { month = "this_month" } = req.query;

    // Reuse the same helpers you used for commissions sync
    const { targetY, targetM } = resolveMonthUTC(month);

    console.log(
      `ðŸ”„ Starting Salesforce DEALS-ONLY sync for: ${month} -> UTC ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")}`
    );

    // Fetch deals:
    // - monthly: for counting deals in the selected month
    // - ytd (or this_year): for lastDealDate (latest in the calendar year)
    const [monthlyDealsResp, ytdDealsResp] = await Promise.all([
      sfGet("/services/apexrest/deals", { month }),
      sfGet("/services/apexrest/deals", { month: "ytd" }),
    ]);

    const monthlyDealsRaw = monthlyDealsResp?.data?.deals || [];
    const ytdDealsRaw = ytdDealsResp?.data?.deals || [];

    // Strict month filter (createddate ONLY), same rule as commissions
    const monthlyDeals = monthlyDealsRaw.filter((d) =>
      isSameUtcMonth(d.createddate, targetY, targetM)
    );

    const agents = await Agent.find({ isActive: true });
    const agentMap = new Map(
      agents.map((a) => [normalizeAgentName(a.agentName), a])
    );

    // ===== MONTHLY DEAL COUNTS =====
    const dealCountsByAgent = new Map();
    const unmatchedMonthly = [];

    for (const deal of monthlyDeals) {
      // âœ… NEW LOGIC: Use deal_agent and deal_agent_2 fields only
      const names = [];

      if (deal.deal_agent) {
        names.push(deal.deal_agent.trim());
      }

      if (deal.deal_agent_2) {
        names.push(deal.deal_agent_2.trim());
      }

      // If no deal_agent fields, skip this deal
      if (names.length === 0) continue;

      for (const nm of names) {
        const key = normalizeAgentName(nm);
        if (!key || !agentMap.has(key)) {
          if (nm && !unmatchedMonthly.includes(nm)) unmatchedMonthly.push(nm);
          continue;
        }
        dealCountsByAgent.set(key, (dealCountsByAgent.get(key) || 0) + 1);
      }
    }

    // ===== YTD LAST DEAL DATE =====
    const ytdDeals = ytdDealsRaw;
    const agentLastDealDateYTD = new Map();
    const unmatchedYtd = [];

    for (const deal of ytdDeals) {
      // âœ… NEW LOGIC: Use deal_agent and deal_agent_2 fields only
      const names = [];

      if (deal.deal_agent) {
        names.push(deal.deal_agent.trim());
      }

      if (deal.deal_agent_2) {
        names.push(deal.deal_agent_2.trim());
      }

      // If no deal_agent fields, skip this deal
      if (names.length === 0) continue;

      const created = deal.createddate;
      const dealDate = created ? new Date(created) : null;
      if (!dealDate || isNaN(dealDate.getTime())) continue;

      for (const nm of names) {
        const key = normalizeAgentName(nm);
        if (!key) continue;

        if (!agentMap.has(key)) {
          if (nm && !unmatchedYtd.includes(nm)) unmatchedYtd.push(nm);
          continue;
        }

        const prev = agentLastDealDateYTD.get(key);
        if (!prev || dealDate > prev) {
          agentLastDealDateYTD.set(key, dealDate);
        }
      }
    }

    // ===== UPDATE AGENTS (DEAL METRICS ONLY) =====
    // Calculate days using UTC midnight for consistency
    const todayUTC = new Date();
    todayUTC.setUTCHours(0, 0, 0, 0);

    const ops = [];
    let agentsUpdated = 0;
    const agentDeals = [];

    for (const [key, agent] of agentMap.entries()) {
      const dealCount = dealCountsByAgent.get(key) || 0;
      const lastDealDate = agentLastDealDateYTD.get(key) || null;

      // Calculate days properly using UTC dates
      let lastDealDays = null;
      if (lastDealDate) {
        const dealDateUTC = new Date(lastDealDate);
        dealDateUTC.setUTCHours(0, 0, 0, 0);

        // Calculate difference in days
        const diffMs = todayUTC.getTime() - dealDateUTC.getTime();
        lastDealDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        // Ensure it's never negative
        lastDealDays = Math.max(0, lastDealDays);
      }

      // Prepare bulk update operation
      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.propertiesSold": dealCount,
              "leaderboard.lastDealDate": lastDealDate,
              "leaderboard.lastDealDays": lastDealDays,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      agentDeals.push({
        agentName: agent.agentName,
        agentId: agent.agentId,
        dealCount,
        lastDealDate,
        daysSinceLastDeal: lastDealDays,
      });

      if (dealCount > 0) agentsUpdated++;
    }

    // Execute bulk update (safe & fast)
    if (ops.length) {
      await Agent.bulkWrite(ops, { ordered: false });
    }

    console.log(
      `âœ… DEALS-ONLY sync completed for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`
    );
    console.log(
      `   - Monthly deals (after strict UTC filter): ${monthlyDeals.length}`
    );
    console.log(`   - YTD deals scanned: ${ytdDeals.length}`);
    console.log(`   - Agents updated: ${agentsUpdated}`);

    return res.status(200).json({
      success: true,
      message: `Successfully synced ${monthlyDeals.length} monthly deals (strict UTC month). Updated ${agentsUpdated} agents with deal counts only.`,
      note: "Deals assigned only to deal_agent and deal_agent_2 (referrers excluded). Month inclusion = createddate in target UTC month.",
      data: {
        period: month,
        targetUTC: { year: targetY, monthIndex0: targetM },
        totalDealsReturnedByAPI: monthlyDealsRaw.length,
        totalDealsCountedAfterStrictFilter: monthlyDeals.length,
        agentsUpdated,
        agentDeals: agentDeals.sort((a, b) => b.dealCount - a.dealCount),
        unmatchedOwners: {
          monthly: unmatchedMonthly,
          ytd: unmatchedYtd,
        },
      },
    });
  } catch (error) {
    console.error("âŒ Error syncing deals:", error.message);
    return res.status(500).json({ success: false, error: error.message });
  }
};

// Fetching monthly commissions
const syncAgentCommissionsFromSalesforce = async (req, res) => {
  try {
    const { month = "this_month" } = req.query;
    const { targetY, targetM } = resolveMonthUTC(month);

    const commissionsResp = await sfGet("/services/apexrest/commissions", {
      month,
    });
    const commissions = commissionsResp?.data?.commissions || [];

    const agents = await Agent.find({ isActive: true });
    const agentMap = new Map(
      agents.map((a) => [normalizeAgentName(a.agentName), a])
    );

    const commissionsByAgent = new Map();
    const unmatchedCommissionAgents = [];
    let filteredCount = 0;

    // Optional: trace
    const traceIncluded = [];
    const traceSkipped = [];

    for (const c of commissions) {
      // âœ… ONLY createddate decides inclusion
      const created = c.createddate; // do not fall back to lastmodifieddate here
      const keep = isSameUtcMonth(created, targetY, targetM);

      if (!keep) {
        // for debugging, capture a few
        if (traceSkipped.length < 20)
          traceSkipped.push({
            ref: c.commission_ref_no,
            agent: c.agent_name || c.commission_agents,
            created,
          });
        continue;
      }

      filteredCount++;
      if (traceIncluded.length < 20)
        traceIncluded.push({
          ref: c.commission_ref_no,
          agent: c.agent_name || c.commission_agents,
          created,
        });

      const agentName = c.agent_name || c.commission_agents;
      if (!agentName) continue;

      const key = normalizeAgentName(agentName);
      if (!agentMap.has(key)) {
        if (!unmatchedCommissionAgents.includes(agentName)) {
          unmatchedCommissionAgents.push(agentName);
        }
        continue;
      }

      const raw = c.commission_amount_excl_vat ?? c.total_commissions ?? 0;
      const amount =
        typeof raw === "string"
          ? Number(raw.replace(/[, ]/g, ""))
          : Number(raw) || 0;

      commissionsByAgent.set(key, (commissionsByAgent.get(key) || 0) + amount);
    }

    // Write back (safe & fast)
    const ops = [];
    const agentCommissions = [];
    let agentsUpdated = 0;

    for (const [key, agent] of agentMap.entries()) {
      const totalCommission =
        Math.round((commissionsByAgent.get(key) || 0) * 100) / 100;

      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.totalCommission": totalCommission,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      if (totalCommission > 0) agentsUpdated++;
      agentCommissions.push({
        agentName: agent.agentName,
        agentId: agent.agentId,
        totalCommission,
        currentDeals: agent.leaderboard?.propertiesSold || 0,
      });
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    return res.status(200).json({
      success: true,
      message: `Synced ${filteredCount} commission records for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`,
      note: "Strict UTC month matching on createddate only.",
      data: {
        period: month,
        targetUTC: { year: targetY, monthIndex0: targetM },
        totalCommissionRecords: commissions.length,
        currentMonthRecords: filteredCount,
        agentsWithCommission: agentsUpdated,
        agentsResetToZero: agents.length - agentsUpdated,
        agentCommissions: agentCommissions
          .filter((a) => a.totalCommission > 0)
          .sort((a, b) => b.totalCommission - a.totalCommission),
        unmatchedAgents: unmatchedCommissionAgents,
        debugSample: {
          includedFirst20: traceIncluded,
          skippedFirst20: traceSkipped,
        },
      },
    });
  } catch (error) {
    console.error("âŒ Error syncing commissions:", error);
    return res.status(500).json({ success: false, error: error.message });
  }
};

// Fetching monthly viewings
const syncAgentViewingsFromSalesforce = async (req, res) => {
  try {
    const { month = "this_month" } = req.query;
    const { targetY, targetM } = resolveMonthUTC(month);

    console.log(
      `ðŸ”„ Starting Salesforce VIEWINGS sync for: ${month} -> UTC ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")}`
    );

    const resp = await sfGet("/services/apexrest/viewings", { month });
    const raw = resp?.data?.viewings || [];

    // âœ… Use start field (primary) for filtering by month
    const viewings = raw.filter((v) => {
      const start = v.start || null;
      return start && isSameUtcMonth(start, targetY, targetM);
    });

    const agents = await Agent.find({ isActive: true });
    const agentMap = new Map(
      agents.map((a) => [normalizeAgentName(a.agentName), a])
    );

    const counts = new Map();
    const unmatchedOwners = new Set();

    for (const v of viewings) {
      const owner = v.owner || v.owner_name || v.agent_name || v.createdById;
      const key = normalizeAgentName(owner);
      if (!key) continue;
      if (agentMap.has(key)) {
        counts.set(key, (counts.get(key) || 0) + 1);
      } else if (owner) {
        unmatchedOwners.add(owner);
      }
    }

    // Write: set viewings for all active agents (0 if none)
    const ops = [];
    let agentsUpdated = 0;

    for (const [key, agent] of agentMap.entries()) {
      const viewingsCount = counts.get(key) || 0;
      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.viewings": viewingsCount,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });
      if (viewingsCount > 0) agentsUpdated++;
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    console.log(
      `âœ… Viewings sync completed for ${targetY}-${String(targetM + 1).padStart(
        2,
        "0"
      )} (UTC).`
    );

    return res.status(200).json({
      success: true,
      message: `Synced ${viewings.length} viewings for ${targetY}-${String(
        targetM + 1
      ).padStart(2, "0")} (UTC).`,
      note: "Strict UTC month matching on 'start' field. Agents without viewings set to 0.",
      data: {
        period: month,
        targetUTC: { year: targetY, monthIndex0: targetM },
        totalViewings: viewings.length,
        agentsUpdated,
        agentViewings: Array.from(counts.entries())
          .map(([k, c]) => ({
            agentName: agentMap.get(k)?.agentName,
            agentId: agentMap.get(k)?.agentId,
            viewingCount: c,
          }))
          .sort((a, b) => b.viewingCount - a.viewingCount),
        unmatchedOwners: unmatchedOwners.size
          ? Array.from(unmatchedOwners)
          : undefined,
      },
    });
  } catch (error) {
    console.error("âŒ Error syncing Salesforce viewings:", error);
    const status = error?.response?.status || 500;
    const msg =
      status === 401
        ? "Salesforce authentication failed. Invalid or expired Bearer token"
        : "Failed to fetch viewings from Salesforce";
    return res.status(status === 401 ? 401 : 503).json({
      success: false,
      error: msg,
      details: error.message,
    });
  }
};

// Updating monthly properties for all agents
const updateMonthlyPropertiesForAllAgents = async (req, res) => {
  try {
    console.log("ðŸ“Š Starting monthly properties update...");

    const result = await Agent.updateAllAgentsMonthlyProperties();

    return res.status(200).json({
      success: true,
      message: "Successfully updated monthly properties for all agents",
      data: result,
    });
  } catch (error) {
    console.error("âŒ Error updating monthly properties:", error.message);
    return res.status(500).json({
      success: false,
      error: "Failed to update monthly properties",
      details: error.message,
    });
  }
};

// Removed Offers Function not needed in backup for future if needed again
// const syncAgentOffersFromSalesforce = async (req, res) => {
//   try {
//     const month = ensureValidMonth(req.query?.month);
//     const { data } = await sfGet("/services/apexrest/Offers", { month });
//     const offers = data?.Offer || [];

//     const agents = await Agent.find({ isActive: true });
//     const agentMap = new Map(
//       agents.map((a) => [normalizeAgentName(a.agentName), a])
//     );

//     const stats = {
//       totalOffers: offers.length,
//       agentsUpdated: 0,
//       unmatchedOwners: new Set(),
//       offersByAgent: new Map(),
//     };

//     for (const o of offers) {
//       const key = normalizeAgentName(o.owner);
//       if (!key) continue;

//       if (agentMap.has(key)) {
//         const cur = stats.offersByAgent.get(key) || 0;
//         stats.offersByAgent.set(key, cur + 1);
//       } else {
//         stats.unmatchedOwners.add(o.owner);
//       }
//     }

//     const updates = [];
//     for (const [key, count] of stats.offersByAgent.entries()) {
//       const agent = agentMap.get(key);
//       if (!agent) continue;
//       agent.updateLeaderboardMetrics({ offers: count });
//       updates.push(agent.save());
//       stats.agentsUpdated++;
//     }
//     await Promise.all(updates);

//     return res.status(200).json({
//       success: true,
//       message: `Successfully synced ${stats.totalOffers} offers and updated ${stats.agentsUpdated} agents`,
//       data: {
//         period: month,
//         totalOffers: stats.totalOffers,
//         agentsUpdated: stats.agentsUpdated,
//         agentOffers: Array.from(stats.offersByAgent.entries()).map(
//           ([key, count]) => ({
//             agentName: agentMap.get(key).agentName,
//             agentId: agentMap.get(key).agentId,
//             offerCount: count,
//           })
//         ),
//         unmatchedOwners:
//           stats.unmatchedOwners.size > 0
//             ? Array.from(stats.unmatchedOwners)
//             : undefined,
//       },
//     });
//   } catch (error) {
//     console.error("âŒ Error syncing Salesforce offers:", error.message);
//     const status = error?.response?.status || 500;
//     const msg =
//       status === 401
//         ? "Salesforce authentication failed. Invalid or expired Bearer token"
//         : "Failed to fetch offers from Salesforce";
//     return res.status(status === 401 ? 401 : 503).json({
//       success: false,
//       error: msg,
//       details: error.message,
//     });
//   }
// };


//New Cron functions

/** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  OLD/EXISTING JOB HELPERS (kept for reference / potential reuse)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  NOTE: Cron no longer calls the per-metric jobs; instead it uses
 *  syncLeaderboardCoreCurrentMonth() above for a single batch update.
 *  Manual endpoints below are kept as-is for debugging/analytics.
 */

// CRON-safe clone of your manual syncAgentDealsFromSalesforce (no req/res)
async function syncDealsJob() {
  try {
    // Always use CURRENT UTC month (no manual/month input)
    const nowUTC = new Date();
    const targetY = nowUTC.getUTCFullYear();
    const targetM = nowUTC.getUTCMonth();

    console.log(
      `ðŸ”„ [DEALS CRON] Sync -> UTC ${targetY}-${String(targetM + 1).padStart(2, "0")}`
    );

    // Fetch monthly & YTD deals
    const [monthlyDealsResp, ytdDealsResp] = await Promise.all([
      sfGet("/services/apexrest/deals", { month: "this_month" }),
      sfGet("/services/apexrest/deals", { month: "ytd" }),
    ]);

    const monthlyDealsRaw = monthlyDealsResp?.data?.deals || [];
    const ytdDealsRaw = ytdDealsResp?.data?.deals || [];

    // Strict UTC month filter
    const monthlyDeals = monthlyDealsRaw.filter((d) =>
      isSameUtcMonth(d.createddate, targetY, targetM)
    );

    const agents = await Agent.find({ isActive: true });
    const agentMap = new Map(
      agents.map((a) => [normalizeAgentName(a.agentName), a])
    );

    // ========== MONTHLY DEAL COUNTS ==========
    const dealCountsByAgent = new Map();
    const unmatchedMonthly = [];

    for (const deal of monthlyDeals) {
      const names = [];
      if (deal.deal_agent) names.push(deal.deal_agent.trim());
      if (deal.deal_agent_2) names.push(deal.deal_agent_2.trim());
      if (names.length === 0) continue;

      for (const nm of names) {
        const key = normalizeAgentName(nm);
        if (!key || !agentMap.has(key)) {
          if (nm && !unmatchedMonthly.includes(nm)) unmatchedMonthly.push(nm);
          continue;
        }
        dealCountsByAgent.set(key, (dealCountsByAgent.get(key) || 0) + 1);
      }
    }

    // ========== YTD LAST DEAL DATE ==========
    const agentLastDealDateYTD = new Map();
    const unmatchedYtd = [];

    for (const deal of ytdDealsRaw) {
      const names = [];
      if (deal.deal_agent) names.push(deal.deal_agent.trim());
      if (deal.deal_agent_2) names.push(deal.deal_agent_2.trim());
      if (names.length === 0) continue;

      const created = deal.createddate;
      const dealDate = created ? new Date(created) : null;
      if (!dealDate || isNaN(dealDate.getTime())) continue;

      for (const nm of names) {
        const key = normalizeAgentName(nm);
        if (!agentMap.has(key)) {
          if (nm && !unmatchedYtd.includes(nm)) unmatchedYtd.push(nm);
          continue;
        }
        const prev = agentLastDealDateYTD.get(key);
        if (!prev || dealDate > prev) agentLastDealDateYTD.set(key, dealDate);
      }
    }

    // ========== UPDATE AGENTS ==========
    const todayUTC = new Date();
    todayUTC.setUTCHours(0, 0, 0, 0);

    const ops = [];
    let agentsUpdated = 0;
    const agentDeals = [];

    for (const [key, agent] of agentMap.entries()) {
      const dealCount = dealCountsByAgent.get(key) || 0;
      const lastDealDate = agentLastDealDateYTD.get(key) || null;

      let lastDealDays = null;
      if (lastDealDate) {
        const dealDateUTC = new Date(lastDealDate);
        dealDateUTC.setUTCHours(0, 0, 0, 0);
        const diffMs = todayUTC - dealDateUTC;
        lastDealDays = Math.max(0, Math.floor(diffMs / (1000 * 60 * 60 * 24)));
      }

      ops.push({
        updateOne: {
          filter: { _id: agent._id },
          update: {
            $set: {
              "leaderboard.propertiesSold": dealCount,
              "leaderboard.lastDealDate": lastDealDate,
              "leaderboard.lastDealDays": lastDealDays,
              "leaderboard.lastUpdated": new Date(),
              lastUpdated: new Date(),
            },
          },
        },
      });

      agentDeals.push({
        agentName: agent.agentName,
        agentId: agent.agentId,
        dealCount,
        lastDealDate,
        daysSinceLastDeal: lastDealDays,
      });

      if (dealCount > 0) agentsUpdated++;
    }

    if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

    console.log(
      `âœ… [DEALS CRON] Completed for ${targetY}-${String(targetM + 1).padStart(
        2,
        "0"
      )} (UTC). Agents updated: ${agentsUpdated}`
    );

    return {
      success: true,
      message: `Successfully synced current-month deals (UTC). Updated ${agentsUpdated} agents.`,
      data: {
        targetUTC: { year: targetY, monthIndex0: targetM },
        totalDealsReturnedByAPI: monthlyDealsRaw.length,
        totalDealsCountedAfterStrictFilter: monthlyDeals.length,
        agentsUpdated,
        agentDeals: agentDeals.sort((a, b) => b.dealCount - a.dealCount),
        unmatchedOwners: {
          monthly: unmatchedMonthly,
          ytd: unmatchedYtd,
        },
      },
    };
  } catch (error) {
    console.error("âŒ [DEALS CRON] Error syncing deals:", error.message);
    return { success: false, error: error.message };
  }
}

/** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  Commissions sync (single dataset; strict UTC current month)
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function syncCommissionsJobNew() {
  const nowUTC = new Date();
  const targetY = nowUTC.getUTCFullYear();
  const targetM = nowUTC.getUTCMonth();

  console.log(
    `ðŸ”„ [COMMISSIONS CORE] Sync -> UTC ${targetY}-${String(targetM + 1).padStart(2, "0")}`
  );

  const commissionsResp = await sfGet("/services/apexrest/commissions");
  const commissions = commissionsResp?.data?.commissions || [];

  const agents = await Agent.find({ isActive: true });
  const agentMap = new Map(
    agents.map((a) => [normalizeAgentName(a.agentName), a])
  );

  const commissionsByAgent = new Map();
  const unmatchedCommissionAgents = [];
  let filteredCount = 0;

  for (const c of commissions) {
    const created = c?.createddate;
    if (!isSameUtcMonth(created, targetY, targetM)) continue;
    filteredCount++;

    const agentName = c.agent_name || c.commission_agents;
    if (!agentName) continue;

    const key = normalizeAgentName(agentName);
    if (!agentMap.has(key)) {
      if (!unmatchedCommissionAgents.includes(agentName))
        unmatchedCommissionAgents.push(agentName);
      continue;
    }

    const raw = c.commission_amount_excl_vat ?? c.total_commissions ?? 0;
    const amt = amountNumber(raw);
    commissionsByAgent.set(key, (commissionsByAgent.get(key) || 0) + amt);
  }

  const canZero = allowZeroingNow();
  const ops = [];
  let agentsUpdated = 0;

  for (const [key, agent] of agentMap.entries()) {
    const totalCommission = Math.round((commissionsByAgent.get(key) || 0) * 100) / 100;

    const $set = {
      "leaderboard.lastUpdated": new Date(),
      lastUpdated: new Date(),
    };
    if (totalCommission !== 0 || canZero) {
      $set["leaderboard.totalCommission"] = totalCommission;
    }

    ops.push({
      updateOne: {
        filter: { _id: agent._id },
        update: { $set },
      },
    });

    if (totalCommission > 0) agentsUpdated++;
  }

  if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

  console.log(
    `âœ… [COMMISSIONS CORE] Completed for ${targetY}-${String(targetM + 1).padStart(
      2,
      "0"
    )} (UTC).`
  );
  console.log(`   - Commission records synced (current month): ${filteredCount}`);
  console.log(`   - Agents updated: ${agentsUpdated}`);

  return {
    targetY,
    targetM,
    filteredCount,
    agentsUpdated,
    unmatchedCommissionAgents,
    totalReturned: commissions.length,
  };
}

/** â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  Viewings sync (single dataset; strict UTC current month by 'start')
 *  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function syncViewingsJob() {
  const nowUTC = new Date();
  const targetY = nowUTC.getUTCFullYear();
  const targetM = nowUTC.getUTCMonth();

  console.log(
    `ðŸ”„ [VIEWINGS CORE] Sync -> UTC ${targetY}-${String(targetM + 1).padStart(2, "0")}`
  );

  const resp = await sfGet("/services/apexrest/viewings");
  const raw = resp?.data?.viewings || [];

  const viewings = raw.filter((v) => {
    const start = v?.start;
    return start && isSameUtcMonth(start, targetY, targetM);
  });

  const agents = await Agent.find({ isActive: true });
  const agentMap = new Map(
    agents.map((a) => [normalizeAgentName(a.agentName), a])
  );

  const counts = new Map();
  const unmatchedOwners = new Set();

  for (const v of viewings) {
    const owner = v.owner || v.owner_name || v.agent_name || v.createdById;
    const key = normalizeAgentName(owner);
    if (!key) continue;

    if (agentMap.has(key)) {
      counts.set(key, (counts.get(key) || 0) + 1);
    } else if (owner) {
      unmatchedOwners.add(owner);
    }
  }

  const canZero = allowZeroingNow();
  const ops = [];
  let agentsUpdated = 0;

  for (const [key, agent] of agentMap.entries()) {
    const viewingsCount = counts.get(key) || 0;

    const $set = {
      "leaderboard.lastUpdated": new Date(),
      lastUpdated: new Date(),
    };
    if (viewingsCount !== 0 || canZero) {
      $set["leaderboard.viewings"] = viewingsCount;
    }

    ops.push({
      updateOne: {
        filter: { _id: agent._id },
        update: { $set },
      },
    });

    if (viewingsCount > 0) agentsUpdated++;
  }

  if (ops.length) await Agent.bulkWrite(ops, { ordered: false });

  console.log(
    `âœ… [VIEWINGS CORE] Done â†’ UTC ${targetY}-${String(targetM + 1).padStart(
      2,
      "0"
    )}, ` +
    `Viewings: ${viewings.length}, Agents Updated: ${agentsUpdated}`
  );

  return {
    targetY,
    targetM,
    totalReturned: raw.length,
    viewingsThisMonth: viewings.length,
    agentsUpdated,
    agentViewings: Array.from(counts.entries())
      .map(([k, c]) => ({
        agentName: agentMap.get(k)?.agentName,
        agentId: agentMap.get(k)?.agentId,
        viewingCount: c,
      }))
      .sort((a, b) => b.viewingCount - a.viewingCount),
    unmatchedOwners: unmatchedOwners.size ? Array.from(unmatchedOwners) : [],
  };
}